<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode - Two Sum Solution</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>LeetCode</h1>
            <p class="problem-title">Two Sum - Problem #1</p>
        </header>

        <nav class="navbar">
            <ul>
                <li><a href="#problem">Problem Statement</a></li>
                <li><a href="#overview">Solution Overview</a></li>
                <li><a href="#steps">Step-by-Step Explanation</a></li>
                <li><a href="#algorithm">Algorithm</a></li>
                <li><a href="#explanation">Detailed Explanation</a></li>
                <li><a href="#video">Video Explanation</a></li>
                <li><a href="#faq">FAQs</a></li>
            </ul>
        </nav>

        <section id="problem" class="problem-description">
<h2 style="text-align: center; display: flex; justify-content: center; align-items: center;">Problem Statement</h2>
            <p>
                Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.
                <br><br>
                You may assume that each input would have exactly one solution, and you may not use the same element twice.
                <br><br>
                You can return the answer in any order.
            </p>
            <div class="example">
                <h3>Example:</h3>
                <pre><code>
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
                </code></pre>
            </div>
        </section>

        <section id="overview" class="solution-overview">
            <h2>Solution Overview</h2>
            <p>To solve the Two Sum problem, we can use a hashmap (also known as a dictionary or hash table) to keep track of the numbers we've seen and their indices. The key insight is that for each number, we can check if the complement (i.e., the difference between the target and the current number) already exists in the hashmap. If it does, we have found the solution. If not, we add the number and its index to the hashmap.</p>
        </section>

        <section id="steps" class="solution-steps">
            <h2>Step-by-Step Explanation</h2>
            <ol>
                <li><strong>Initialize a hashmap:</strong> Create an empty hashmap to store the numbers we encounter and their indices.</li>
                <li><strong>Iterate through the array:</strong> Loop through the array of numbers, keeping track of the current index.</li>
                <li><strong>Calculate the complement:</strong> For each number, calculate the complement by subtracting the number from the target (i.e., <code>complement = target - nums[i]</code>).</li>
                <li><strong>Check the hashmap:</strong> If the complement is already in the hashmap, we have found the two numbers that add up to the target. Return their indices.</li>
                <li><strong>Add to the hashmap:</strong> If the complement is not in the hashmap, add the current number and its index to the hashmap.</li>
                <li><strong>Return the result:</strong> Once the loop is complete, the solution has been found and returned.</li>
            </ol>
        </section>

        <section id="algorithm" class="algorithm-section">
            <h2>Algorithm</h2>
            <pre><code>
function twoSum(nums, target) {
    // Step 1: Create an empty hashmap to store numbers and their indices
    const map = new Map();

    // Step 2: Loop through each number in the array
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];

        // Step 3: Check if the complement exists in the hashmap
        if (map.has(complement)) {
            // Step 4: If found, return the indices
            return [map.get(complement), i];
        }

        // Step 5: If not found, add the number and its index to the hashmap
        map.set(nums[i], i);
    }

    // Step 6: Return an empty array if no solution is found (though the problem guarantees a solution)
    return [];
}
            </code></pre>
        </section>

        <section id="explanation" class="detailed-explanation">
            <h2>Detailed Explanation</h2>
            <p>
                The algorithm uses a hashmap to store each number's index as we iterate through the array. The key insight is that for each number <code>nums[i]</code>, we want to check if the complement (i.e., <code>target - nums[i]</code>) has already been seen in the array. If it has, then the pair of indices (i.e., the current index <code>i</code> and the index of the complement in the hashmap) form a solution.
            </p>
            <p>
                This approach works in a single pass through the array, making it more efficient than the brute-force method, which would require checking each pair of numbers. The time complexity is O(n), where n is the number of elements in the array, and the space complexity is also O(n) because of the additional storage used by the hashmap.
            </p>
        </section>
<section id="solution-code">
    <h2>Solution Code</h2>
    <pre><code class="language-cpp">
// Two Sum Solution in C++

#include <vector>
#include <unordered_map>
using namespace std;

vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> num_map;
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (num_map.find(complement) != num_map.end()) {
            return {num_map[complement], i};
        }
        num_map[nums[i]] = i;
    }
    return {};
}
    </code></pre>
</section>

        <section id="video" class="video-explanation">
            <h2>Video Explanation</h2>
            <p>Watch the video below for a detailed walkthrough of the solution:</p>
            <div class="video-container">
                <iframe width="560" height="315" src="https://www.youtube.com/embed/Eqf1VsGe9O8" frameborder="0" allowfullscreen></iframe>
            </div>
        </section>

        <section id="faq" class="faq-section">
            <h2>Frequently Asked Questions</h2>
            <div class="faq-item">
                <h3>Q1: What if the array has negative numbers?</h3>
                <p>A: The algorithm still works with negative numbers because the complement is calculated as <code>target - nums[i]</code>, so it can correctly handle cases where the target is positive or negative.</p>
            </div>
            <div class="faq-item">
                <h3>Q2: What is the time complexity of this solution?</h3>
                <p>A: The time complexity is O(n), where n is the number of elements in the array. This is because we are iterating through the array once and performing constant-time operations during each iteration.</            </div>
            <div class="faq-item">
                <h3>Q3: Can this algorithm be optimized further?</h3>
                <p>A: This algorithm is already optimal in terms of time complexity for the problem as stated. The only improvement would be in reducing space complexity, but that would typically require sacrificing time complexity.</p>
            </div>
        </section>

        <footer class="footer">
            <p>Created by <a href="https://github.com/reallywasi">Your Name</a></p>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>
